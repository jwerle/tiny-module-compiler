#!/usr/bin/env node

const { compile, archive } = require('../')
const { version } = require('../package.json')
const prettyBytes = require('pretty-bytes')
const minimist = require('minimist')
const mkdirp = require('mkdirp')
const Batch = require('batch')
const debug = require('debug')('tiny-module-compiler')
const path = require('path')
const fs = require('fs')

const argv = minimist(process.argv.slice(2), {
  boolean: [
    'help',
    'debug',
    'version',

    'archive',
    'compile',
    'source-map',
  ],

  string: [
    'output'
  ],

  array: [
    'external'
  ],

  alias: {
    // bools
    A: 'assets',
    D: 'debug',
    h: 'help',
    M: 'source-map',
    V: 'version',

    // main
    a: 'archive',
    c: 'compile',

    // config
    e: 'external',
    o: 'output',
    x: 'external',
  }
})

const usage = `usage: tmc [-hDV] [options] ...input
where options can be:

  -a, --archive             If present, will archive input into "tinybox" format
  -A, --copy-assets         If present, will copy assets to directory of output
  -c, --compile             If present, will compile input into header prefixed v8 cached data
  -D, --debug               If present, will enable debug output (DEBUG=tiny-module-compiler)
  -e, --external <module>   Specifies an external dependency that will be linked at runtime
  -h, --help                If present, will print this message
  -M, --source-map          If present, a source map will be generated
  -o, --output <filename>   If present, will change the output filename
  -V, --version             If present, will print the version number
  -x                        An alias for '--external'
`

if (argv.version) {
  console.log(version)
  process.exit(0)
}

if (argv.debug) {
  require('debug').enable(`tiny-module-compiler*,${process.env.DEBUG || ''}`)
}

if (argv.help || 0 === argv._.length) {
  if (argv.help) {
    console.log(usage)
    process.exit(0)
  } else {
    console.error(usage)
    process.exit(1)
  }
}

if (argv.compile || !argv.archive) { // default
  argv.externals = [ ].concat(argv.external).filter(Boolean)
  if (argv['source-map']) {
    argv.map = true
  }

  if (argv.output && 'string' === typeof argv.output) {
    argv.output = path.resolve(argv.output)
    if (1 === argv._.length) {
      mkdirp.sync(argv.output)
    } else {
      mkdirp.sync(path.dirname(argv.output))
    }
  }

  compile(argv._, argv, (err, objects, assets) => {
    if (err) {
      console.error('error:', err.message)
      debug(err)
      return process.exit(1)
    }

    if (argv['copy-assets']) {
      const writes = new Batch()
      for (let [ filename, asset ] of assets) {
        filename = path.join(path.dirname(argv.output), filename)
        writes.push((next) => {
          const opts = { mode: asset.permissions }
          console.warn(' warn: writing %s (%s)',
            filename.replace(process.cwd(), '.'),
            prettyBytes(asset.source.length),
            opts.mode.toString(8))

          fs.writeFile(filename, asset.source, opts, next)
        })
      }

      writes.end((err) => {
        if (err) {
          console.error('error:', err.message)
          debug(err)
          return process.exit(1)
        }
      })
    }
  })
}

if (!argv.compile && argv.archive) {
  archive(argv._[0], argv._.slice(1), argv, (err) => {
    if (err) {
      console.error('error:', err.message)
      debug(err)
      return process.exit(1)
    }
  })
}
